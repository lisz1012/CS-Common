# 内核同步机制（简单介绍）

## 关于同步理论的一些基本概念
- 临界区（critical area）：访问或操作共享数据的代码段。简单理解就是synchronied打括号中的部分（原子性）
- 竞争条件（race condition）两个线程同时拥有林攫取的执行权
- 数据不一致：data unconsistency 有竞争条件引起的数据破坏
- 同步 （synchronization） 避免race conditions
- 锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在）上锁解所必须具备原子性。Lock指令，需要底层的支持
- 原子性：像原子一样不可分割的操作
- 有序性：禁止指令重排
- 可见性：一个线程内修改，另一个线程可见

## 内核同步常用方法
原子性、有序性、可见性  
1、原子操作 - 内核中类似AtomicXXX，位于linux/types.h cmpxchg原语提供了原子性操作  
2、自旋锁 - 内核中通过汇编支持CAS，位于asm/spinloc.h. 上面一种从原语层面上就支持，无需自旋，所以这一种比上一种效率稍低
3、读写自旋 - 类似于ReadWriteLock，Read锁是一个共享锁，Write锁是一个独占锁，可以同时读，只能一个写。只有写操作完成并进行通知之后，所有
   等待的读操作才能继续执行（写操作之间依靠synchronized关键进行），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现
   上述功能，只需要在读操作时获取读锁，写操作时获取锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有
   操作继续执行，
4、信号量 - 类似于Semaphore（PV操作 down up操作，占有和释放） 重量级锁，线程会进入Wait，适合长时间持有锁的情况。不要把内核里面的Semaphore
   跟Java里面的Semaphore完全对等，Java里的Semaphore是自旋，而这里的是要进入wait。但是语义上是一样的，信号量够了以后就会限流。Semaphore
   是所有锁的祖宗，只有0和1两个值的Semaphore就是一把独占锁。up增一个数字就是加锁，down下来就是释放锁了，这是两个原子操作，原子操作用Lock
   指令。
5、读写信号量 - downread upread downwrite upwrite （多个写、可以分段写，比较少用），读写两把锁，或者一把锁上的两种condition。类似Lock
   指令，有读写两个队列。读的线程来了，upread占有锁，写的线程来了upwrite占有锁。多个写非常少用到，因为很容易改变数据一致性，比如分段锁
   （CurrentHashMap 在Java 1.7以前的做法）
6、互斥体（mutex） - 特殊的信号量（二值信号量），正统的锁，互斥锁，实际上是一种特殊的Semaphore，只有0和1
7、完成变量 - 特殊的信号量（A发出信号给B，B等待在完成变量上），相当于回调，一个线程在等另一个线程执行结束才能继续执行。很像是CountdownLatch。
   vfork()在子进程结束的时候，通过完成变量叫醒父进程，类似于Latch。AIO是event模型，事件发生之后回调，效率非常高，但是Linux不支持。java
   AIO用的还是epoll而不是完成变量的模式，AIO只有Windows真正实现了
9、顺序锁（kernel 2.6）：- 线程可以挂起的读写自旋锁。序列计数器（从0开始，写实增加（+1），写完释放（+1），读的时候发现是单数，则说明有线程
   正在写它，那就等待。读前读后序列一样，说明没有写线程打断）。写的时候还是只允许一个线程。他跟ReadWriteLock的区别在于读线程可以不停下来
   wait，接不接受脏读，读线程自己看着办，选择自旋就等着。像CopyOnWrite


锁的理论特别多，新的锁在不断出现，AQS可以让我们手动实现各种各样的锁

## 汇编实现引导程序