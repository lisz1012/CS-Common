# 内核同步机制（简单介绍）

## 关于同步理论的一些基本概念
- 临界区（critical area）：访问或操作共享数据的代码段。简单理解就是synchronied打括号中的部分（原子性）
- 竞争条件（race condition）两个线程同时拥有林攫取的执行权
- 数据不一致：data unconsistency 有竞争条件引起的数据破坏
- 同步 （synchronization） 避免race conditions
- 锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在）上锁解所必须具备原子性。Lock指令，需要底层的支持
- 原子性：像原子一样不可分割的操作
- 有序性：禁止指令重排
- 可见性：一个线程内修改，另一个线程可见
- 互斥锁、拍他所、共享锁、分段锁

## 内核同步常用方法
原子性、有序性、可见性  
1、原子操作 - 内核中类似AtomicXXX，位于linux/types.h cmpxchg原语提供了原子性操作  
2、自旋锁 - 内核中通过汇编支持CAS，位于asm/spinloc.h. 上面一种从原语层面上就支持，无需自旋，所以这一种比上一种效率稍低
3、读写自旋 - 类似于ReadWriteLock，Read锁是一个共享锁，Write锁是一个独占锁，可以同时读，只能一个写。只有写操作完成并进行通知之后，所有
   等待的读操作才能继续执行（写操作之间依靠synchronized关键进行），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现
   上述功能，只需要在读操作时获取读锁，写操作时获取锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有
   操作继续执行，
4、信号量 - 类似于Semaphore（PV操作 down up操作，占有和释放） 重量级锁，线程会进入Wait，适合长时间持有锁的情况。不要把内核里面的Semaphore
   跟Java里面的Semaphore完全对等，Java里的Semaphore是自旋，而这里的是要进入wait。但是语义上是一样的，信号量够了以后就会限流。Semaphore
   是所有锁的祖宗，只有0和1两个值的Semaphore就是一把独占锁。up增一个数字就是加锁，down下来就是释放锁了，这是两个原子操作，原子操作用Lock
   指令。
5、读写信号量 - downread upread downwrite upwrite （多个写、可以分段写，比较少用），读写两把锁，或者一把锁上的两种condition。类似Lock
   指令，有读写两个队列。读的线程来了，upread占有锁，写的线程来了upwrite占有锁。多个写非常少用到，因为很容易改变数据一致性，比如分段锁
   （CurrentHashMap 在Java 1.7以前的做法）
6、互斥体（mutex） - 特殊的信号量（二值信号量），正统的锁，互斥锁，实际上是一种特殊的Semaphore，只有0和1
7、完成变量 - 特殊的信号量（A发出信号给B，B等待在完成变量上），相当于回调，一个线程在等另一个线程执行结束才能继续执行。很像是CountdownLatch。
   vfork()在子进程结束的时候，通过完成变量叫醒父进程，类似于Latch。AIO是event模型，事件发生之后回调，效率非常高，但是Linux不支持。java
   AIO用的还是epoll而不是完成变量的模式，AIO只有Windows真正实现了
9、顺序锁（kernel 2.6）：- 线程可以挂起的读写自旋锁。序列计数器（从0开始，写实增加（+1），写完释放（+1），读的时候发现是单数，则说明有线程
   正在写它，那就等待。读前读后序列一样，说明没有写线程打断）。写的时候还是只允许一个线程。他跟ReadWriteLock的区别在于读线程可以不停下来
   wait，接不接受脏读，读线程自己看着办，选择自旋就等着。像CopyOnWrite
10、禁止抢占 - preempt_disable() 当前这个线程在执行的过程之中不允许别的线程来抢占或打断。Java里面没有对应的操作，只有内核才有的调用，一般
   是在处理终端的时候才用得上，写跟他相关的程序要小心。某个值确认只有一个CPU用，这种情况下，没必要给他上锁。单核CPU也可以运行多线程的，所以
   单核CPU要访问的这个数据也是需要上锁的，如果确认只有这一个CPU要访问的时候，就不用上锁，用"禁止抢占"就可以了。这是非常底层的优化操作，
   不重要，没人考
11、内存屏障 - 见volatile

锁的理论特别多，新的锁在不断出现，AQS可以让我们手动实现各种各样的锁

## 汇编实现引导程序
把下列程序放入软盘第一个扇区，然后开始从软盘启动，BIOS上来就读它，然后放到内存的固定位置
```java
; 文件名 boot.asm
org 7c00h                                       ; BIOS/UEFI读入MBR之后，从7c00h处开始执行，引导程序一定要放在这里

; 下面部分和10h有关中断, 10h中断用来显示字符
mov ax, cs
mov es, ax
mov ax, msg
mov bp, ax                                      ; ES:BP表示显示字符串的地址
mov cx, msgLen                                  ; CX存字符长度
mov ax, 1301h                                   ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）
mov bx, 000fh                                   ; BH=00h表示页号，BL=0fh表示颜色
mov dl, 0                                       ; 列
int 10h

msg: db "hello world, welcome to OS!"
msgLen: equ $ - msg                             ; 字符串长度
times 510 - ($ - $$) db 0                       ; 填充剩余部分
dw 0aa55h                                       ; 魔数，必须有这两个字节BIOS才确认是MBR
```
从这里可以开始从做系统制作之旅


## 汇编实现引导程序