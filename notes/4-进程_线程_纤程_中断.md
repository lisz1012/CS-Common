# 进程 线程 纤程 中断
面试高频：进程和线程有什么区别？纯理论问题。进程是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。这个答案不太准确，比较口语化。
进程是OS用来分配资源的基本单位，线程是OS执行调度的基本单位。双击一个exe，他会被load到内存（有内存映射的过程），分配相应的资源，形成一个进程。
在双击一次exe，理论上来说又会启动一个进程，位于内存中不同的位置，会被分配资源：最重要的就是内存中独立的地址空间，其他还有寄存器、PC、打开的
文件等。  

Load到内存之后，CPU开始读进程中的一条一条的指令来放到PC里执行，其中如果除了main线程还有不同的线程，这各个线程到底CPU执行哪一个，是CPU调度
的基本单位。各个线程共享进程的内存空间，没有自己独立的内存空间。  

一个进程内部可以有多个纤程，一个线程可以有多个纤程

## 线程

### 线程在Linux中的实现
每个OS其实不太一样。在Linux中，就是一个普通的进程，只不过和其他进程共享资源（内存空间、全局数据等...）其他系统都有各自所谓的LWP（Light 
Weight Process）的实现。高层面理解：一个进程中不同的执行路线。Linux起一个进程就是一个fork()系统调用，可以用C语言写。他会从现有的进程里面
克隆出一个新的进程来，这俩一个叫父进程一个叫子进程，站在OS的角度来讲，想再父进程里启动一个新线程，其实也是一个新进程，只不过这个线程和fork
出去的子进程共享了同一块内存空间。所以线程跟进程在Linux里面没有太大区别。其他系统都有自己的LWP，一个进程中不同的执行路线，有一个主进程，
和其他的进程（主进程的线程）共享内存空间（Linux）。

## 纤程
### 纤程和JVM线程的关系
纤程是线程中的线程：在用户空间的线程。JVM跑在用户态，其中的线程目前的模型是：Thread类的
对象就是启动一个LWP，就是普通的进程，JVM空间的一个线程对应着OS的一个线程，重量级线程，这就要通过OS内核了，得向OS申请资源、经过他的批准，
中间有一层系统调用才能实现，然后得从用户态转变为内核态，完了之后还得从内核态同步回用户态。Hotspot JVM的线程和OS的线程是一一对应的（有的是
多对一，有调度）。由于启动JVM线程太重，我们又在线程内部分出了好多分支，线程里面的线程 -- 纤程。各个纤程并行，但他们并不直接对应OS级别的重量
级的线程，而是被JVM调度。线程执行一会儿纤程1在执行一会儿纤程2...简单理解，这个线程就是软件CPU，而各个纤程就是跑在这个软CPU上不同的线程。
线程在用户空间，不需要跟内核打交道，也不需要OS启动一个对应的线程，OS内核起不了多少线程，资源见全部被耗费在线程的切换和调度上。但是JVM中的
切换是在用户空间发生的，甚至都不需要跟硬件打交道，只需要在JVM内部完成。所以纤程非常轻量级，切换非常快，能启动几十万个。多个纤程对应一个JVM
中的线程

### 纤程实现原理
跟OS中对于线程的调度的实现是一模一样的：每一个纤程在堆里实现一个栈结构：纤程栈。线程在不同的纤程栈之间切换，切换之前保存好当前纤程栈的变量值。
相当于他自己实现了一个小小的操作系统级别的调度。这有什么好处吗？它的特点是跑在用户态。纤程，用户态的线程，线程中的线程，切换和调度不需要经过
OS。优势：1、占有资源很少，1M数据要给一个线程，包括TLAB等，县城只占用4k。2、切换比较简单。3、可以启动很多个，10W+。目前内置纤程的：Kotlin、
scala、go、python + lib... Java通过类库的方式可以，但是很不幸今天的JDK-14还是没有纤程，要加入类库才可以支持（open JDK + loom）。Java
纤程做同样的工作，用时是线程的1/2（马士兵的机器上）。纤程主要应用在很短的计算任务上，不需要跟内核打交道，不需要读文件或网络，或者并发量比较高
的时候（纤程起上万个跟玩儿似的）。就盼着Java出纤程库，然后Go也就没有什么值得骄傲的了

## PCB

Process Control Block：进程描述符。Linux内核数据结构。大小不固定，不同的进程不一样。Linux管理进程的时候把进程信息就记录在这个数据结构
里面。Linux里面也称作task。在Linux中，每一个线程也是个普通的进程，所以每一个线程也有PCB，只不过有的记录着跟别人共享内存空间，或者独享
内存空间。面试说出来这一点会比较拽

## 内核线程（不重要）

仅仅运行在内核空间的线程，内核启动之后自己启动的一些线程，用来执行一些背后的操作，比如计时、定期清理垃圾等，用户空间的东西不可能直接访问他们，
只能通过内核间接协调访问。

## Linux下启动进程
系统函数fork()、exec()，生成和跑起新的一个子进程. 其中fork()下面调用的是clone()克隆出一个新的子进程。通过内核做一些事情，就是系统函数。

### 僵尸进程
父进程产生了一堆子进程之后，会维护着各个子进程的PCB数据结构，当一个子进程退出之后，讲道理应该由父进程释放这个结构，但是其父进程如果没有释放，
那么子进程就成为一个僵尸进程：zombie.c。绝大多数情况下没有什么影响，但是太多了不太行，自己写C程序得注意。子进程执行完了，父进程不退出，那就
会出现僵尸进程。僵尸进程只消耗一个PCB的空间。defunct

### 孤儿进程
子进程结束之前，父进程已经退出，孤儿进程就会成为init进程的孩子，由1号进程维护它的PCB：orphan.c。产生孤儿进程之后没有任何影响，无非就是换了
个爹，新爹替他维护PCB

## 进程调度
操作系统做的最重要的事情就是进程调度。优先执行什么进程、执行多长时间、什么时候切换。Linux下有各种各样的调度方案，Linux灵活在可以指定某个进程
特定的调度方案。Dos和Win3.1是单人舞的。后来的OS压榨CPU资源，大厂也喜欢要能压榨CPU资源的亻。

### 进程调度算法
- 非抢占式：cooperative multitasking。除非进程主动让出CPU，别人才有执行机会，否则他就一直运行。特殊的OS，如军方的，会采用的比较多  
- 抢占式：preemptive multitasking。由进程调度器强制开始或暂停（抢占）某一个进程的执行。现代OS多用这一种。

### Linux下具体的进程调度（选修，但是好玩儿）
- Linux 2.5 经典Unix O(1)调度策略，按照时间片，每隔若干个毫秒在进程间切换一次。偏向服务器，但对UI交互不友好，因为响应不及时
- Linux 2.6.23（目前） 采用CFS完全公平调度算法 Completely Fair Scheduler， CFS。不再采用绝对时间片。绝对公平反而未必公平，因为有的
  进程可能不需要这个时间片。最新的内核里面按照优先级的比例来分配时间片。执行到某个进程的时候发现他没动，就不给他时间片，当这个进程又开始动的
  时候，OS其实记录了每个进程执行的时间，会察觉到当初欠他的时间片来着，然后就优先执行这个线程，什么时候大致和其他的进程用的时间片相当了，什么
  时候就有差不多的分配了

### 进程类型
- IO密集型：大部分时间等待IO。不必把时间优先分配给他，什么时候网络IO来了再给他。
- CPU密集型：大部分时间用于闷头计算。

### 进程优先级
- 实时进程 > 普通进程（0 - 99）实时进程是急诊，一定优先于普通进程进行。实时进程的高级别一定在实时进程低级别和普通进程之前执行。调度策略是：
  使用SCHED_FIFO和SCHED_RR
- 普通进程nice值（-20 ～ 19）。优先级只决定了一个执行时间的比例，不是完全的先后。调度策略是CFS

实时进程中，等级最高的是FIFO（优先级最高的先执行），这种进程除非自己让出CPU，否则Linux会一直执行它，除非更高等级的FIFO和RR抢占他。RR只是
这种线程中同级别的FIFO的平均分配，两个都断脖子的，医生轮着施救。只有实时进程主动让出，或者执行完毕后，普通进程才有机会运行。实时进程JVM创建
不了，拿C语言来创建。

### 时间分配
- Linux采用按照优先级的CPU时间比
- 其他系统多采用按优先级的时间片

### eg.两个app同时运行
- 一个文本处理程序
- 一个影视后期程序

## 中断
中断硬件和操作系统通信的一种机制。不管OS或者应用程序在干嘛，只要有一些硬件的反应，都是需要优先执行的，比如敲键盘、网络数据来了、打印完成...
都要在软件上作出反馈。相当于，用硬件的电信号控制软件的输出。这就需要中断控制器（一个芯片），他会告诉CPU有个专门接收终端信号的针脚，特定的
寄存器上会告诉CPU这个终端信号（比如说）是从硬盘来的，那什么决定了收了这个信号之后执行什么？CPU去内存中的固定位置去找处理程序，而这个程序是由
操作系统放在这里的。终端信号来了，先去查是那种类型的中断，然后去查这种类型的中断在中断向量表里对应的程序是哪一个，然后从那个固定的位置上把它
给揪出来，执行。终端信号来了，是什么样子的，打包交给kernel，kernel找到对应的中断处理程序，进行处理。具体分为上下半场：内核处理的是上半场，
应用程序处理的是下半场。比如kernel发现Office在最前态，正在准备处理输入，他就会把这个信号交给Office。

### 硬中断
来自硬件，如硬盘、网卡、打印机、时钟计时器的中断

### 软中断
做系统调用，跟OS内核打交道的时候有软中断（0x80，对应着很多系统调用函数，200多个）。先打断并且告诉内核，要和硬盘打交道了，然后通过系统调用
进行硬件的访问，比如访问硬盘。内核被0x80打断了就知道，要被应用程序调用200个系统调用中的一个了。然后应用程序要告诉OS具体调用的是哪一个函数。
