# 进程 线程 纤程 中断
面试高频：进程和线程有什么区别？纯理论问题。进程是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。这个答案不太准确，比较口语化。
进程是OS用来分配资源的基本单位，线程是OS执行调度的基本单位。双击一个exe，他会被load到内存（有内存映射的过程），分配相应的资源，形成一个进程。
在双击一次exe，理论上来说又会启动一个进程，位于内存中不同的位置，会被分配资源：最重要的就是内存中独立的地址空间，其他还有寄存器、PC、打开的
文件等。  

Load到内存之后，CPU开始读进程中的一条一条的指令来放到PC里执行，其中如果除了main线程还有不同的线程，这各个线程到底CPU执行哪一个，是CPU调度
的基本单位。各个线程共享进程的内存空间，没有自己独立的内存空间。  

## 线程

### 线程在Linux中的实现
每个OS其实不太一样。在Linux中，就是一个普通的进程，只不过和其他进程共享资源（内存空间、全局数据等...）其他系统都有各自所谓的LWP（Light 
Weight Process）的实现。高层面理解：一个进程中不同的执行路线。Linux起一个进程就是一个fork()系统调用，可以用C语言写。他会从现有的进程里面
克隆出一个新的进程来，这俩一个叫父进程一个叫子进程，站在OS的角度来讲，想再父进程里启动一个新线程，其实也是一个新进程，只不过这个线程和fork
出去的子进程共享了同一块内存空间。所以线程跟进程在Linux里面没有太大区别。其他系统都有自己的LWP，一个进程中不同的执行路线，有一个主进程，
和其他的进程（主进程的线程）共享内存空间（Linux）。

## 纤程
### 纤程和JVM线程的关系
纤程是线程中的线程：在用户空间的线程。JVM跑在用户态，其中的线程目前的模型是：Thread类的
对象就是启动一个LWP，就是普通的进程，JVM空间的一个线程对应着OS的一个线程，重量级线程，这就要通过OS内核了，得向OS申请资源、经过他的批准，
中间有一层系统调用才能实现，然后得从用户态转变为内核态，完了之后还得从内核态同步回用户态。Hotspot JVM的线程和OS的线程是一一对应的（有的是
多对一，有调度）。由于启动JVM线程太重，我们又在线程内部分出了好多分支，线程里面的线程 -- 纤程。各个纤程并行，但他们并不直接对应OS级别的重量
级的线程，而是被JVM调度。线程执行一会儿纤程1在执行一会儿纤程2...简单理解，这个线程就是软件CPU，而各个纤程就是跑在这个软CPU上不同的线程。
线程在用户空间，不需要跟内核打交道，也不需要OS启动一个对应的线程，OS内核起不了多少线程，资源见全部被耗费在线程的切换和调度上。但是JVM中的
切换是在用户空间发生的，甚至都不需要跟硬件打交道，只需要在JVM内部完成。所以纤程非常轻量级，切换非常快，能启动几十万个。多个纤程对应一个JVM
中的线程

### 纤程实现原理
跟OS中对于线程的调度的实现是一模一样的：每一个纤程在堆里实现一个栈结构：纤程栈。线程在不同的纤程栈之间切换，切换之前保存好当前纤程栈的变量值。
相当于他自己实现了一个小小的操作系统级别的调度。这有什么好处吗？