# 内存管理

## 早期的操作系统进程
- Dos时代，单进程，同一时间内，只能有一个进程在运行（也有一些特殊算法支持Dos里面的多进程）。
- Win 9x：多进程装入内存。读个进程全部装到内存里，容易把内存撑爆，也可能互相打扰，不小心访问到了别人的空间。这两个问题催生了现代OS的内存管理
          方式，而且现代OS的内存管理是软硬件结合实现的。现代内存管理：虚拟地址、分页装入、软硬结合寻址
## 现代OS内存管理
把硬盘上的程序进行分页，内存也进行分页，程序的分页可以往内存的分页里装。程序和内存页都是4k分页，也有支持64k大分页的，但是基础的就是4k。内存中
的每一页叫做页框，Page Frame。用到哪一块，就往里装哪一块程序，什么时候用到其他小块的程序了，再装入他们。实际上已经把程序大卸八块了，懒加载，只是
程序的椰表记录下来了，与此同时告诉了进程调度器，说这个可执行程序的入口是在第三页上，然后限制是加载第三页，执行的时候发现需要第四块的数据，那
就再加载第四块的内容进入内存。然后第五块也要拿进来的时候发现全满了，那就用LRU的算法，把那个最不常用的拿到swap分区里面去，swap效率很低。
什么时候swap里面的一块程序又要用到了，再从swap、加载回来，然后把内存中最不常用的一块给他扔回swap。用这样一种方式，就能支持更多的、更灵活的
进程管理。刚一开始执行程序的时候，甚至仅仅只是加载了一个页表。  

LRU算法：Leetcode 146，头条要求手撕，阿里去年也要求手撕。所有涉及到缓存的时候，都有LRU和LFU算法进行缓存清除。LRU的算法：HashMap + 链表，
前者保证查找O(1)，后者保证排序和新增操作是O(1)的时间复杂度