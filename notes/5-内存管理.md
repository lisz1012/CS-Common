# 内存管理

## 早期的操作系统进程
- Dos时代，单进程，同一时间内，只能有一个进程在运行（也有一些特殊算法支持Dos里面的多进程）。
- Win 9x：多进程装入内存。读个进程全部装到内存里，容易把内存撑爆，也可能互相打扰，不小心访问到了别人的空间。这两个问题催生了现代OS的内存管理
          方式，而且现代OS的内存管理是软硬件结合实现的。现代内存管理：虚拟地址、分页装入、软硬结合寻址
## 现代OS内存管理
把硬盘上的程序进行分页，内存也进行分页，程序的分页可以往内存的分页里装。程序和内存页都是4k分页，也有支持64k大分页的，但是基础的就是4k。内存中
的每一页叫做页框，Page Frame。用到哪一块，就往里装哪一块程序，而不是一次性的把程序整个加载进来。什么时候用到其他小块的程序了，再装入他们。
实际上已经把程序大卸八块了，懒加载，只是
程序的椰表记录下来了，与此同时告诉了进程调度器，说这个可执行程序的入口是在第三页上，然后限制是加载第三页，执行的时候发现需要第四块的数据，那
就再加载第四块的内容进入内存。然后第五块也要拿进来的时候发现全满了，那就用LRU的算法，把那个最不常用的拿到swap分区里面去，swap效率很低。
什么时候swap里面的一块程序又要用到了，再从swap、加载回来，然后把内存中最不常用的一块给他扔回swap。用这样一种方式，就能支持更多的、更灵活的
进程管理。刚一开始执行程序的时候，甚至仅仅只是加载了一个页表。  

LRU算法：Leetcode 146，头条要求手撕，阿里去年也要求手撕。所有涉及到缓存的时候，都有LRU和LFU算法进行缓存清除。LRU的算法：HashMap + 链表，
前者保证查找O(1)，后者保证排序和新增操作是O(1)的时间复杂度   

分页解决了内存不够用的问题，但是相互打扰的问题怎么解决？虚拟内存  
Dos/Win3.1 这种古老的系统，两个进程是可以直接访问到内存的物理地址的。这样甚至可以把OS弄死机。新的OS为了保证互不影响，让进程工作在虚拟的空间，
而不是直接的物理地址。所以进程是不可能访问到别的进程的内存的。虚拟空间是多大呢？就是寻址空间，64位是2^64,32位就是2^32字节。站在虚拟的角度，
进程是独享整个系统 + CPU，全是他的，当然了也是用到哪块就把哪块装进内存。虚拟空间有固定的格式。程序的内部的虚拟空间是分成一段一段的，有数据段、
代码段、共享库（printf、read）、用户栈、内核专属空间等。怎么把虚拟地址和物理地址联系起来？访问的是虚拟地址，实际装到了物理内存中的某一个地方
了。一段一段的内部才细分各个4k的页，真正用到哪一页了，才把它加载到物理内存。这就会产生一个问题：虚拟地址怎么跟物理地址一一对应起来？这叫内存
映射。

### 为什么使用虚拟内存？
- 隔离应用程序：每个程序都认为自己有连续可用的内存。突破物理内存的限制。应用程序不需要考虑物理内存是否够用，是否能分配等底层问题。
- 安全：保护物理内存不被恶意程序访问

### 怎样从逻辑地址映射到物理地址？
逻辑地址：code里面写在20这个地址的数据，main函数默认20这个地址在数据段。那数据段位于整个虚拟地址空间的那个地址呢？整个数据区如果位于1000，
则线性地址=逻辑地址（偏移量）+段的基地址。线性地址还是虚拟空间的，怎么把它映射到物理空间去？OS + MMU （Memory Management Unit）配合完成。
这个过程就知道是由OS+MMU这个硬件来完成的就行了。这个过程是没有任何用户空间的程序来参与的，除了OS内核没人知道，所以OS就安全了。每个进程都认为
他自己是独占OS内核的，其实并不是。

### 缺页中断（不重要）
某一块还没有从硬盘load到内存，则会有一个缺页中断或者缺页异常，跟OS说，哥们儿，我这里缺了一页，OS就会找到页表，把缺的页码所对应的硬盘的空间
找到，然后加载到内存

### ZGC
Colored Pointer。GC信息记录在指针生而不是对象头的Markword上，immediate memory use，内存立即就可以重用。比如说有个对象要被回收的时候
并不改markword，如果要重用这块内存，发现指针的信息已经改了，则立即可以重用。ZGC把64位指针中的42位拿出来做寻址空间，也就是4T。4位拿出来做Colored 
Pointer（Finalized、Remapped、Marked1、Marked0，互斥，不可能两个都为1），想再扩充寻址空间，就再从剩下的18位里面，拿出2位来，但是最多
也就44位，16T的寻址空间，
因为硬件制造商偷懒。先从别的题讲起。CPU如何区分一个立即数？总线内部分为：数据总线、地址总线、控制总线。一个数据到底是个数据还是个指令，就看
它是从哪条线过来的。地址总线目前只有48位，48位已经够了，所以寻址只有48位给我们用，少了16根地址总线。已经有4位给颜色指针了，所以最多再扩充两位，
到16T。ZGC采用了虚拟空间，每一个状态的对象位于不同的4T地址空间，在实际映射的时候，会映射到物理内存的同一块空间。ZGC目前不支持32位的系统和
Windows，只支持Linux。JVM很多很厉害的算法都来自Linux内核。CAS锁来自Linux内核的Futex锁，颜色指针借助了虚拟地址的概念。Linux是个瑰宝，如果
说评选一个最🐂的程序员，只能是Linus。Linux中很多东西都是自创的比如进程调度算法CFS