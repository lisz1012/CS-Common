# 内存管理

## 早期的操作系统进程
- Dos时代，单进程，同一时间内，只能有一个进程在运行（也有一些特殊算法支持Dos里面的多进程）。
- Win 9x：多进程装入内存。读个进程全部装到内存里，容易把内存撑爆，也可能互相打扰，不小心访问到了别人的空间。这两个问题催生了现代OS的内存管理
          方式，而且现代OS的内存管理是软硬件结合实现的。现代内存管理：虚拟地址、分页装入、软硬结合寻址
## 现代OS内存管理
把硬盘上的程序进行分页，内存也进行分页，程序的分页可以往内存的分页里装。程序和内存页都是4k分页，也有支持64k大分页的，但是基础的就是4k。内存中
的每一页叫做页框，Page Frame。用到哪一块，就往里装哪一块程序，什么时候用到其他小块的程序了，再装入他们。实际上已经把程序大卸八块了，懒加载，只是
程序的椰表记录下来了，与此同时告诉了进程调度器，说这个可执行程序的入口是在第三页上，然后限制是加载第三页，执行的时候发现需要第四块的数据，那
就再加载第四块的内容进入内存。然后第五块也要拿进来的时候发现全满了，那就用LRU的算法，把那个最不常用的拿到swap分区里面去，swap效率很低。
什么时候swap里面的一块程序又要用到了，再从swap、加载回来，然后把内存中最不常用的一块给他扔回swap。用这样一种方式，就能支持更多的、更灵活的
进程管理。刚一开始执行程序的时候，甚至仅仅只是加载了一个页表。  

LRU算法：Leetcode 146，头条要求手撕，阿里去年也要求手撕。所有涉及到缓存的时候，都有LRU和LFU算法进行缓存清除。LRU的算法：HashMap + 链表，
前者保证查找O(1)，后者保证排序和新增操作是O(1)的时间复杂度   

分页解决了内存不够用的问题，但是相互打扰的问题怎么解决？虚拟内存  
Dos/Win3.1 这种古老的系统，两个进程是可以直接访问到内存的物理地址的。这样甚至可以把OS弄死机。新的OS为了保证互不影响，让进程工作在虚拟的空间，
而不是直接的物理地址。所以进程是不可能访问到别的进程的内存的。虚拟空间是多大呢？就是寻址空间，64位是2^64,32位就是2^32字节。站在虚拟的角度，
进程是独享整个系统 + CPU，全是他的，当然了也是用到哪块就把哪块装进内存。虚拟空间有固定的格式。程序的内部的虚拟空间是分成一段一段的，有数据段、
代码段、共享库（printf、read）、用户栈、内核专属空间等。怎么把虚拟地址和物理地址联系起来？访问的是虚拟地址，实际装到了物理内存中的某一个地方
了。一段一段的内部才细分各个4k的页，真正用到哪一页了，才把它加载到物理内存。这就会产生一个问题：虚拟地址怎么跟物理地址一一对应起来？这叫内存
映射。